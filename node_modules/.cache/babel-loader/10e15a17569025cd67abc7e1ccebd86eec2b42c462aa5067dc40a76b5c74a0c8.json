{"ast":null,"code":"import { atom } from 'jotai/vanilla';\nconst RESET = Symbol((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"RESET\" : \"\");\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(initialValue, (get, set, update) => {\n    const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n    set(anAtom, nextValue === RESET ? initialValue : nextValue);\n  });\n  return anAtom;\n}\nfunction atomWithReducer(initialValue, reducer) {\n  return atom(initialValue, function (get, set, action) {\n    set(this, reducer(get(this), action));\n  });\n}\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */new Map();\n  const createAtom = param => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = param => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = fn => {\n    shouldRemove = fn;\n    if (!shouldRemove) return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$3 = /* @__PURE__ */new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */new WeakMap(), cache1$3, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(() => {\n    const EMPTY = Symbol();\n    const selectValue = ([value, prevSlice]) => {\n      if (prevSlice === EMPTY) {\n        return selector(value);\n      }\n      const slice = selector(value, prevSlice);\n      return equalityFn(prevSlice, slice) ? prevSlice : slice;\n    };\n    const derivedAtom = atom(get => {\n      const prev = get(derivedAtom);\n      const value = get(anAtom);\n      return selectValue([value, prev]);\n    });\n    derivedAtom.init = EMPTY;\n    return derivedAtom;\n  }, anAtom, selector, equalityFn);\n}\nconst frozenAtoms = /* @__PURE__ */new WeakSet();\nconst deepFreeze = obj => {\n  if (typeof obj !== \"object\" || obj === null) return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  if (frozenAtoms.has(anAtom)) {\n    return anAtom;\n  }\n  frozenAtoms.add(anAtom);\n  const origRead = anAtom.read;\n  anAtom.read = function (get, options) {\n    return deepFreeze(origRead.call(this, get, options));\n  };\n  if (\"write\" in anAtom) {\n    const origWrite = anAtom.write;\n    anAtom.write = function (get, set, ...args) {\n      return origWrite.call(this, get, (...setArgs) => {\n        if (setArgs[0] === anAtom) {\n          setArgs[1] = deepFreeze(setArgs[1]);\n        }\n        return set(...setArgs);\n      }, ...args);\n    };\n  }\n  return anAtom;\n}\nfunction freezeAtomCreator(createAtom) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\"[DEPRECATED] freezeAtomCreator is deprecated, define it on users end\");\n  }\n  return (...args) => freezeAtom(createAtom(...args));\n}\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = atom2 => !!atom2.write;\nconst isFunction = x => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(() => {\n    const mappingCache = /* @__PURE__ */new WeakMap();\n    const getMapping = (arr, prev) => {\n      let mapping = mappingCache.get(arr);\n      if (mapping) {\n        return mapping;\n      }\n      const prevMapping = prev && mappingCache.get(prev);\n      const atomList = [];\n      const keyList = [];\n      arr.forEach((item, index) => {\n        const key = keyExtractor ? keyExtractor(item) : index;\n        keyList[index] = key;\n        const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n        if (cachedAtom) {\n          atomList[index] = cachedAtom;\n          return;\n        }\n        const read = get => {\n          const prev2 = get(mappingAtom);\n          const currArr = get(arrAtom);\n          const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n          const index2 = mapping2.keyList.indexOf(key);\n          if (index2 < 0 || index2 >= currArr.length) {\n            const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n            if (prevItem) {\n              return prevItem;\n            }\n            throw new Error(\"splitAtom: index out of bounds for read\");\n          }\n          return currArr[index2];\n        };\n        const write = (get, set, update) => {\n          const prev2 = get(mappingAtom);\n          const arr2 = get(arrAtom);\n          const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n          const index2 = mapping2.keyList.indexOf(key);\n          if (index2 < 0 || index2 >= arr2.length) {\n            throw new Error(\"splitAtom: index out of bounds for write\");\n          }\n          const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n          if (!Object.is(arr2[index2], nextItem)) {\n            set(arrAtom, [...arr2.slice(0, index2), nextItem, ...arr2.slice(index2 + 1)]);\n          }\n        };\n        atomList[index] = isWritable(arrAtom) ? atom(read, write) : atom(read);\n      });\n      if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n        mapping = prevMapping;\n      } else {\n        mapping = {\n          arr,\n          atomList,\n          keyList\n        };\n      }\n      mappingCache.set(arr, mapping);\n      return mapping;\n    };\n    const mappingAtom = atom(get => {\n      const prev = get(mappingAtom);\n      const arr = get(arrAtom);\n      const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n      return mapping;\n    });\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mappingAtom.debugPrivate = true;\n    }\n    mappingAtom.init = void 0;\n    const splittedAtom = isWritable(arrAtom) ? atom(get => get(mappingAtom).atomList, (get, set, action) => {\n      switch (action.type) {\n        case \"remove\":\n          {\n            const index = get(splittedAtom).indexOf(action.atom);\n            if (index >= 0) {\n              const arr = get(arrAtom);\n              set(arrAtom, [...arr.slice(0, index), ...arr.slice(index + 1)]);\n            }\n            break;\n          }\n        case \"insert\":\n          {\n            const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n            if (index >= 0) {\n              const arr = get(arrAtom);\n              set(arrAtom, [...arr.slice(0, index), action.value, ...arr.slice(index)]);\n            }\n            break;\n          }\n        case \"move\":\n          {\n            const index1 = get(splittedAtom).indexOf(action.atom);\n            const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n            if (index1 >= 0 && index2 >= 0) {\n              const arr = get(arrAtom);\n              if (index1 < index2) {\n                set(arrAtom, [...arr.slice(0, index1), ...arr.slice(index1 + 1, index2), arr[index1], ...arr.slice(index2)]);\n              } else {\n                set(arrAtom, [...arr.slice(0, index2), arr[index1], ...arr.slice(index2, index1), ...arr.slice(index1 + 1)]);\n              }\n            }\n            break;\n          }\n      }\n    }) : atom(get => get(mappingAtom).atomList);\n    return splittedAtom;\n  }, arrAtom, keyExtractor || cacheKeyForEmptyKeyExtractor);\n}\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = atom((get, options) => {\n    const overwritten = get(overwrittenAtom);\n    if (overwritten !== EMPTY) {\n      return overwritten;\n    }\n    return getDefault(get, options);\n  }, (get, set, update) => {\n    if (update === RESET) {\n      set(overwrittenAtom, EMPTY);\n    } else if (typeof update === \"function\") {\n      const prevValue = get(anAtom);\n      set(overwrittenAtom, update(prevValue));\n    } else {\n      set(overwrittenAtom, update);\n    }\n  });\n  return anAtom;\n}\nconst isPromiseLike = x => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction withStorageValidator(validator) {\n  return unknownStorage => {\n    const storage = {\n      ...unknownStorage,\n      getItem: (key, initialValue) => {\n        const validate = value2 => {\n          if (!validator(value2)) {\n            return initialValue;\n          }\n          return value2;\n        };\n        const value = unknownStorage.getItem(key, initialValue);\n        if (isPromiseLike(value)) {\n          return value.then(validate);\n        }\n        return validate(value);\n      }\n    };\n    return storage;\n  };\n}\nfunction createJSONStorage(getStringStorage = () => {\n  try {\n    return window.localStorage;\n  } catch (e) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      if (typeof window !== \"undefined\") {\n        console.warn(e);\n      }\n    }\n    return void 0;\n  }\n}, options) {\n  var _a;\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a2, _b;\n      const parse = str2 => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);\n          } catch (e) {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;\n      if (isPromiseLike(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(key, JSON.stringify(newValue, options == null ? void 0 : options.replacer));\n    },\n    removeItem: key => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);\n    }\n  };\n  const createHandleSubscribe = subscriber2 => (key, callback, initialValue) => subscriber2(key, v => {\n    let newValue;\n    try {\n      newValue = JSON.parse(v || \"\");\n    } catch (e) {\n      newValue = initialValue;\n    }\n    callback(newValue);\n  });\n  let subscriber;\n  try {\n    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;\n  } catch (e) {}\n  if (!subscriber && typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    subscriber = (key, callback) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {};\n      }\n      const storageEventCallback = e => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          callback(e.newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  if (subscriber) {\n    storage.subscribe = createHandleSubscribe(subscriber);\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage();\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, options) {\n  const getOnInit = options == null ? void 0 : options.getOnInit;\n  const baseAtom = atom(getOnInit ? storage.getItem(key, initialValue) : initialValue);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = setAtom => {\n    setAtom(storage.getItem(key, initialValue));\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = atom(get => get(baseAtom), (get, set, update) => {\n    const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n    if (nextValue === RESET) {\n      set(baseAtom, initialValue);\n      return storage.removeItem(key);\n    }\n    if (nextValue instanceof Promise) {\n      return nextValue.then(resolvedValue => {\n        set(baseAtom, resolvedValue);\n        return storage.setItem(key, resolvedValue);\n      });\n    }\n    set(baseAtom, nextValue);\n    return storage.setItem(key, nextValue);\n  });\n  return anAtom;\n}\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = result => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = atom(get => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise(r => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = result => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: d => listener({\n          d\n        }),\n        error: e => listener({\n          e\n        }),\n        complete: () => {}\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = update => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = atom(get => {\n    const [resultAtom] = get(observableResultAtom);\n    const result = get(resultAtom);\n    if (result instanceof Promise) {\n      return result.then(returnResultData);\n    }\n    return returnResultData(result);\n  }, (get, set, data) => {\n    const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n    if (\"next\" in observable) {\n      if (isNotMounted()) {\n        set(resultAtom, makePending());\n        start();\n      }\n      observable.next(data);\n    } else {\n      throw new Error(\"observable is not subject\");\n    }\n  });\n  return observableAtom;\n}\nconst cache1$1 = /* @__PURE__ */new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst isPromise$1 = x => x instanceof Promise;\nconst LOADING = {\n  state: \"loading\"\n};\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = atom((get, {\n      setSelf\n    }) => {\n      get(refreshAtom);\n      let value;\n      try {\n        value = get(anAtom);\n      } catch (error) {\n        return {\n          state: \"hasError\",\n          error\n        };\n      }\n      if (!isPromise$1(value)) {\n        return {\n          state: \"hasData\",\n          data: value\n        };\n      }\n      const promise = value;\n      const cached1 = loadableCache.get(promise);\n      if (cached1) {\n        return cached1;\n      }\n      if (promise.status === \"fulfilled\") {\n        loadableCache.set(promise, {\n          state: \"hasData\",\n          data: promise.value\n        });\n      } else if (promise.status === \"rejected\") {\n        loadableCache.set(promise, {\n          state: \"hasError\",\n          error: promise.reason\n        });\n      } else {\n        promise.then(data => {\n          loadableCache.set(promise, {\n            state: \"hasData\",\n            data\n          });\n        }, error => {\n          loadableCache.set(promise, {\n            state: \"hasError\",\n            error\n          });\n        }).finally(setSelf);\n      }\n      const cached2 = loadableCache.get(promise);\n      if (cached2) {\n        return cached2;\n      }\n      loadableCache.set(promise, LOADING);\n      return LOADING;\n    }, (_get, set) => {\n      set(refreshAtom, c => c + 1);\n    });\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return atom(get => get(derivedAtom));\n  }, anAtom);\n}\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst isPromise = x => x instanceof Promise;\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(() => {\n    const promiseErrorCache = /* @__PURE__ */new WeakMap();\n    const promiseResultCache = /* @__PURE__ */new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const promiseAndValueAtom = atom((get, {\n      setSelf\n    }) => {\n      get(refreshAtom);\n      const prev = get(promiseAndValueAtom);\n      const promise = get(anAtom);\n      if (!isPromise(promise)) {\n        return {\n          v: promise\n        };\n      }\n      if (promise !== (prev == null ? void 0 : prev.p)) {\n        if (promise.status === \"fulfilled\") {\n          promiseResultCache.set(promise, promise.value);\n        } else if (promise.status === \"rejected\") {\n          promiseErrorCache.set(promise, promise.reason);\n        } else {\n          promise.then(v => promiseResultCache.set(promise, v), e => promiseErrorCache.set(promise, e)).finally(setSelf);\n        }\n      }\n      if (promiseErrorCache.has(promise)) {\n        throw promiseErrorCache.get(promise);\n      }\n      if (promiseResultCache.has(promise)) {\n        return {\n          p: promise,\n          v: promiseResultCache.get(promise)\n        };\n      }\n      if (prev && \"v\" in prev) {\n        return {\n          p: promise,\n          f: fallback(prev.v),\n          v: prev.v\n        };\n      }\n      return {\n        p: promise,\n        f: fallback()\n      };\n    }, (_get, set) => {\n      set(refreshAtom, c => c + 1);\n    });\n    promiseAndValueAtom.init = void 0;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      promiseAndValueAtom.debugPrivate = true;\n    }\n    return atom(get => {\n      const state = get(promiseAndValueAtom);\n      if (\"f\" in state) {\n        return state.f;\n      }\n      return state.v;\n    }, (_get, set, ...args) => set(anAtom, ...args));\n  }, anAtom, fallback);\n}\nfunction atomWithRefresh(read, write) {\n  const refreshAtom = atom(0);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    refreshAtom.debugPrivate = true;\n  }\n  return atom((get, options) => {\n    get(refreshAtom);\n    return read(get, options);\n  }, (get, set, ...args) => {\n    if (args.length === 0) {\n      set(refreshAtom, c => c + 1);\n    } else if (write) {\n      return write(get, set, ...args);\n    }\n  });\n}\nfunction atomWithLazy(makeInitial) {\n  const a = atom(void 0);\n  delete a.init;\n  Object.defineProperty(a, \"init\", {\n    get() {\n      return makeInitial();\n    }\n  });\n  return a;\n}\nexport { RESET, atomFamily, atomWithDefault, atomWithLazy, atomWithObservable, atomWithReducer, atomWithRefresh, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, withStorageValidator as unstable_withStorageValidator, unwrap };","map":{"version":3,"names":["atom","RESET","Symbol","import","meta","env","MODE","atomWithReset","initialValue","anAtom","get","set","update","nextValue","atomWithReducer","reducer","action","atomFamily","initializeAtom","areEqual","shouldRemove","atoms","Map","createAtom","param","item","key","value","remove","newAtom","Date","now","delete","setShouldRemove","fn","getCached$2","c","m","k","has","cache1$3","WeakMap","memo3","create","dep1","dep2","dep3","cache2","cache3","selectAtom","selector","equalityFn","Object","is","EMPTY","selectValue","prevSlice","slice","derivedAtom","prev","init","frozenAtoms","WeakSet","deepFreeze","obj","freeze","propNames","getOwnPropertyNames","name","freezeAtom","add","origRead","read","options","call","origWrite","write","args","setArgs","freezeAtomCreator","console","warn","getCached$1","cache1$2","memo2$1","cacheKeyForEmptyKeyExtractor","isWritable","atom2","isFunction","x","splitAtom","arrAtom","keyExtractor","mappingCache","getMapping","arr","mapping","prevMapping","atomList","keyList","forEach","index","cachedAtom","indexOf","prev2","mappingAtom","currArr","mapping2","index2","length","prevItem","Error","arr2","nextItem","every","i","debugPrivate","splittedAtom","type","before","index1","atomWithDefault","getDefault","overwrittenAtom","overwritten","prevValue","isPromiseLike","then","withStorageValidator","validator","unknownStorage","storage","getItem","validate","value2","createJSONStorage","getStringStorage","window","localStorage","e","_a","lastStr","lastValue","_a2","_b","parse","str2","JSON","reviver","str","setItem","newValue","stringify","replacer","removeItem","createHandleSubscribe","subscriber2","callback","v","subscriber","subscribe","addEventListener","Storage","storageEventCallback","storageArea","removeEventListener","defaultStorage","atomWithStorage","getOnInit","baseAtom","onMount","setAtom","unsub","Promise","resolvedValue","atomWithObservable","getObservable","returnResultData","result","d","observableResultAtom","observable","itself","resolve","makePending","r","initialResult","setResult","lastResult","listener","subscription","timer","isNotMounted","start","clearTimeout","unsubscribe","next","error","complete","unstable_timeout","setTimeout","resultAtom","observableAtom","data","cache1$1","memo1","isPromise$1","LOADING","state","loadable","loadableCache","refreshAtom","setSelf","promise","cached1","status","reason","finally","cached2","_get","getCached","cache1","memo2","isPromise","defaultFallback","unwrap","fallback","promiseErrorCache","promiseResultCache","promiseAndValueAtom","p","f","atomWithRefresh","atomWithLazy","makeInitial","a","defineProperty","unstable_withStorageValidator"],"sources":["/Users/orcor/react/careplus/node_modules/jotai/esm/vanilla/utils.mjs"],"sourcesContent":["import { atom } from 'jotai/vanilla';\n\nconst RESET = Symbol(\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"RESET\" : \"\"\n);\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  return atom(initialValue, function(get, set, action) {\n    set(this, reducer(get(this), action));\n  });\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove) return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache1$3, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(\n    () => {\n      const EMPTY = Symbol();\n      const selectValue = ([value, prevSlice]) => {\n        if (prevSlice === EMPTY) {\n          return selector(value);\n        }\n        const slice = selector(value, prevSlice);\n        return equalityFn(prevSlice, slice) ? prevSlice : slice;\n      };\n      const derivedAtom = atom((get) => {\n        const prev = get(derivedAtom);\n        const value = get(anAtom);\n        return selectValue([value, prev]);\n      });\n      derivedAtom.init = EMPTY;\n      return derivedAtom;\n    },\n    anAtom,\n    selector,\n    equalityFn\n  );\n}\n\nconst frozenAtoms = /* @__PURE__ */ new WeakSet();\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null) return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  if (frozenAtoms.has(anAtom)) {\n    return anAtom;\n  }\n  frozenAtoms.add(anAtom);\n  const origRead = anAtom.read;\n  anAtom.read = function(get, options) {\n    return deepFreeze(origRead.call(this, get, options));\n  };\n  if (\"write\" in anAtom) {\n    const origWrite = anAtom.write;\n    anAtom.write = function(get, set, ...args) {\n      return origWrite.call(\n        this,\n        get,\n        (...setArgs) => {\n          if (setArgs[0] === anAtom) {\n            setArgs[1] = deepFreeze(setArgs[1]);\n          }\n          return set(...setArgs);\n        },\n        ...args\n      );\n    };\n  }\n  return anAtom;\n}\nfunction freezeAtomCreator(createAtom) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] freezeAtomCreator is deprecated, define it on users end\"\n    );\n  }\n  return (...args) => freezeAtom(createAtom(...args));\n}\n\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read = (get) => {\n            const prev2 = get(mappingAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write = (get, set, update) => {\n            const prev2 = get(mappingAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            if (!Object.is(arr2[index2], nextItem)) {\n              set(arrAtom, [\n                ...arr2.slice(0, index2),\n                nextItem,\n                ...arr2.slice(index2 + 1)\n              ]);\n            }\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read, write) : atom(read);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { arr, atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const mappingAtom = atom((get) => {\n        const prev = get(mappingAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n        return mapping;\n      });\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        mappingAtom.debugPrivate = true;\n      }\n      mappingAtom.init = void 0;\n      const splittedAtom = isWritable(arrAtom) ? atom(\n        (get) => get(mappingAtom).atomList,\n        (get, set, action) => {\n          switch (action.type) {\n            case \"remove\": {\n              const index = get(splittedAtom).indexOf(action.atom);\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  ...arr.slice(index + 1)\n                ]);\n              }\n              break;\n            }\n            case \"insert\": {\n              const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  action.value,\n                  ...arr.slice(index)\n                ]);\n              }\n              break;\n            }\n            case \"move\": {\n              const index1 = get(splittedAtom).indexOf(action.atom);\n              const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index1 >= 0 && index2 >= 0) {\n                const arr = get(arrAtom);\n                if (index1 < index2) {\n                  set(arrAtom, [\n                    ...arr.slice(0, index1),\n                    ...arr.slice(index1 + 1, index2),\n                    arr[index1],\n                    ...arr.slice(index2)\n                  ]);\n                } else {\n                  set(arrAtom, [\n                    ...arr.slice(0, index2),\n                    arr[index1],\n                    ...arr.slice(index2, index1),\n                    ...arr.slice(index1 + 1)\n                  ]);\n                }\n              }\n              break;\n            }\n          }\n        }\n      ) : atom((get) => get(mappingAtom).atomList);\n      return splittedAtom;\n    },\n    arrAtom,\n    keyExtractor || cacheKeyForEmptyKeyExtractor\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = atom(\n    (get, options) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get, options);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        set(overwrittenAtom, EMPTY);\n      } else if (typeof update === \"function\") {\n        const prevValue = get(anAtom);\n        set(overwrittenAtom, update(prevValue));\n      } else {\n        set(overwrittenAtom, update);\n      }\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction withStorageValidator(validator) {\n  return (unknownStorage) => {\n    const storage = {\n      ...unknownStorage,\n      getItem: (key, initialValue) => {\n        const validate = (value2) => {\n          if (!validator(value2)) {\n            return initialValue;\n          }\n          return value2;\n        };\n        const value = unknownStorage.getItem(key, initialValue);\n        if (isPromiseLike(value)) {\n          return value.then(validate);\n        }\n        return validate(value);\n      }\n    };\n    return storage;\n  };\n}\nfunction createJSONStorage(getStringStorage = () => {\n  try {\n    return window.localStorage;\n  } catch (e) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      if (typeof window !== \"undefined\") {\n        console.warn(e);\n      }\n    }\n    return void 0;\n  }\n}, options) {\n  var _a;\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a2, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);\n          } catch (e) {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;\n      if (isPromiseLike(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(\n        key,\n        JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n      );\n    },\n    removeItem: (key) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);\n    }\n  };\n  const createHandleSubscribe = (subscriber2) => (key, callback, initialValue) => subscriber2(key, (v) => {\n    let newValue;\n    try {\n      newValue = JSON.parse(v || \"\");\n    } catch (e) {\n      newValue = initialValue;\n    }\n    callback(newValue);\n  });\n  let subscriber;\n  try {\n    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;\n  } catch (e) {\n  }\n  if (!subscriber && typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    subscriber = (key, callback) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {\n        };\n      }\n      const storageEventCallback = (e) => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          callback(e.newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  if (subscriber) {\n    storage.subscribe = createHandleSubscribe(subscriber);\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage();\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, options) {\n  const getOnInit = options == null ? void 0 : options.getOnInit;\n  const baseAtom = atom(\n    getOnInit ? storage.getItem(key, initialValue) : initialValue\n  );\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = (setAtom) => {\n    setAtom(storage.getItem(key, initialValue));\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      if (nextValue instanceof Promise) {\n        return nextValue.then((resolvedValue) => {\n          set(baseAtom, resolvedValue);\n          return storage.setItem(key, resolvedValue);\n        });\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = (result) => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (result instanceof Promise) {\n        return result.then(returnResultData);\n      }\n      return returnResultData(result);\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst isPromise$1 = (x) => x instanceof Promise;\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */ new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = atom(\n      (get, { setSelf }) => {\n        get(refreshAtom);\n        let value;\n        try {\n          value = get(anAtom);\n        } catch (error) {\n          return { state: \"hasError\", error };\n        }\n        if (!isPromise$1(value)) {\n          return { state: \"hasData\", data: value };\n        }\n        const promise = value;\n        const cached1 = loadableCache.get(promise);\n        if (cached1) {\n          return cached1;\n        }\n        if (promise.status === \"fulfilled\") {\n          loadableCache.set(promise, { state: \"hasData\", data: promise.value });\n        } else if (promise.status === \"rejected\") {\n          loadableCache.set(promise, {\n            state: \"hasError\",\n            error: promise.reason\n          });\n        } else {\n          promise.then(\n            (data) => {\n              loadableCache.set(promise, { state: \"hasData\", data });\n            },\n            (error) => {\n              loadableCache.set(promise, { state: \"hasError\", error });\n            }\n          ).finally(setSelf);\n        }\n        const cached2 = loadableCache.get(promise);\n        if (cached2) {\n          return cached2;\n        }\n        loadableCache.set(promise, LOADING);\n        return LOADING;\n      },\n      (_get, set) => {\n        set(refreshAtom, (c) => c + 1);\n      }\n    );\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return atom((get) => get(derivedAtom));\n  }, anAtom);\n}\n\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst isPromise = (x) => x instanceof Promise;\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(\n    () => {\n      const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n      const promiseResultCache = /* @__PURE__ */ new WeakMap();\n      const refreshAtom = atom(0);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n      }\n      const promiseAndValueAtom = atom(\n        (get, { setSelf }) => {\n          get(refreshAtom);\n          const prev = get(promiseAndValueAtom);\n          const promise = get(anAtom);\n          if (!isPromise(promise)) {\n            return { v: promise };\n          }\n          if (promise !== (prev == null ? void 0 : prev.p)) {\n            if (promise.status === \"fulfilled\") {\n              promiseResultCache.set(promise, promise.value);\n            } else if (promise.status === \"rejected\") {\n              promiseErrorCache.set(promise, promise.reason);\n            } else {\n              promise.then(\n                (v) => promiseResultCache.set(promise, v),\n                (e) => promiseErrorCache.set(promise, e)\n              ).finally(setSelf);\n            }\n          }\n          if (promiseErrorCache.has(promise)) {\n            throw promiseErrorCache.get(promise);\n          }\n          if (promiseResultCache.has(promise)) {\n            return {\n              p: promise,\n              v: promiseResultCache.get(promise)\n            };\n          }\n          if (prev && \"v\" in prev) {\n            return { p: promise, f: fallback(prev.v), v: prev.v };\n          }\n          return { p: promise, f: fallback() };\n        },\n        (_get, set) => {\n          set(refreshAtom, (c) => c + 1);\n        }\n      );\n      promiseAndValueAtom.init = void 0;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        promiseAndValueAtom.debugPrivate = true;\n      }\n      return atom(\n        (get) => {\n          const state = get(promiseAndValueAtom);\n          if (\"f\" in state) {\n            return state.f;\n          }\n          return state.v;\n        },\n        (_get, set, ...args) => set(anAtom, ...args)\n      );\n    },\n    anAtom,\n    fallback\n  );\n}\n\nfunction atomWithRefresh(read, write) {\n  const refreshAtom = atom(0);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    refreshAtom.debugPrivate = true;\n  }\n  return atom(\n    (get, options) => {\n      get(refreshAtom);\n      return read(get, options);\n    },\n    (get, set, ...args) => {\n      if (args.length === 0) {\n        set(refreshAtom, (c) => c + 1);\n      } else if (write) {\n        return write(get, set, ...args);\n      }\n    }\n  );\n}\n\nfunction atomWithLazy(makeInitial) {\n  const a = atom(void 0);\n  delete a.init;\n  Object.defineProperty(a, \"init\", {\n    get() {\n      return makeInitial();\n    }\n  });\n  return a;\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithLazy, atomWithObservable, atomWithReducer, atomWithRefresh, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, withStorageValidator as unstable_withStorageValidator, unwrap };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}