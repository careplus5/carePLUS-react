{"ast":null,"code":"let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(this, typeof arg === \"function\" ? arg(get(this)) : arg);\n}\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = atom => \"init\" in atom;\nconst isActuallyWritableAtom = atom => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {}).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = x => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = a => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = atomState => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore$1 = () => {\n  const atomStateMap = /* @__PURE__ */new WeakMap();\n  const mountedMap = /* @__PURE__ */new WeakMap();\n  const pendingStack = [];\n  const pendingMap = /* @__PURE__ */new WeakMap();\n  let devListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    devListenersRev2 = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n  const getAtomState = atom => atomStateMap.get(atom);\n  const addPendingDependent = (atom, atomState) => {\n    atomState.d.forEach((_, a) => {\n      if (!pendingMap.has(a)) {\n        const aState = getAtomState(a);\n        pendingMap.set(a, [aState, /* @__PURE__ */new Set()]);\n        if (aState) {\n          addPendingDependent(a, aState);\n        }\n      }\n      pendingMap.get(a)[1].add(atom);\n    });\n  };\n  const setAtomState = (atom, atomState) => {\n    var _a;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, [prevAtomState, /* @__PURE__ */new Set()]);\n      addPendingDependent(atom, atomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\n    const dependencies = new Map(keepPreviousDependencies ? nextAtomState.d : null);\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies);\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(v => {\n          if (!settled) {\n            settled = true;\n            resolvePromise(promise, v);\n            resolve(v);\n            updatePromiseDependencies();\n          }\n        }, e => {\n          if (!settled) {\n            settled = true;\n            rejectPromise(promise, e);\n            reject(e);\n            updatePromiseDependencies();\n          }\n        });\n        continuePromise = next => {\n          if (!settled) {\n            settled = true;\n            next.then(v => resolvePromise(promise, v), e => rejectPromise(promise, e));\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, next => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!(force == null ? void 0 : force(atom)) && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a, force);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */new Map();\n    let isSync = true;\n    const getter = a => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a, force);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, () => controller == null ? void 0 : controller.abort());\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = atom => returnAtomValue(readAtomState(atom));\n  const recomputeDependents = atom => {\n    const getDependents = a => {\n      var _a, _b;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach(dependent => {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    const topsortedAtoms = new Array();\n    const markedAtoms = /* @__PURE__ */new Set();\n    const visit = n => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */new Set([atom]);\n    const isMarked = a => markedAtoms.has(a);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const prevAtomState = getAtomState(a);\n      if (!prevAtomState) {\n        continue;\n      }\n      let hasChangedDeps = false;\n      for (const dep of prevAtomState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        const nextAtomState = readAtomState(a, isMarked);\n        addPendingDependent(a, nextAtomState);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n      markedAtoms.delete(a);\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    const getter = a => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      const isSync = pendingStack.length > 0;\n      if (!isSync) {\n        pendingStack.push( /* @__PURE__ */new Set([a]));\n      }\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending(pendingStack.pop());\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          devListenersRev2.forEach(l => l({\n            type: \"async-write\",\n            flushed\n          }));\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    pendingStack.push( /* @__PURE__ */new Set([atom]));\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending(pendingStack.pop());\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      devListenersRev2.forEach(l => l({\n        type: \"write\",\n        flushed\n      }));\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const existingMount = mountedMap.get(atom);\n    if (existingMount) {\n      if (initialDependent) {\n        existingMount.t.add(initialDependent);\n      }\n      return existingMount;\n    }\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      if (a !== atom) {\n        mountAtom(a, atom, queue);\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const {\n        onMount\n      } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach(f => f());\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const tryUnmountAtom = (atom, mounted) => {\n    if (!canUnmountAtom(atom, mounted)) {\n      return;\n    }\n    const onUnmount = mounted.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mountedDep = mountedMap.get(a);\n          if (mountedDep) {\n            mountedDep.t.delete(atom);\n            tryUnmountAtom(a, mountedDep);\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach(a => {\n      mountAtom(a, atom);\n    });\n    maybeUnmountAtomSet.forEach(a => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        tryUnmountAtom(a, mounted);\n      }\n    });\n  };\n  const flushPending = pendingAtoms => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */new Set();\n    }\n    const pending = [];\n    const collectPending = pendingAtom => {\n      var _a;\n      if (!pendingMap.has(pendingAtom)) {\n        return;\n      }\n      const [prevAtomState, dependents] = pendingMap.get(pendingAtom);\n      pendingMap.delete(pendingAtom);\n      pending.push([pendingAtom, prevAtomState]);\n      dependents.forEach(collectPending);\n      (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a) => collectPending(a));\n    };\n    pendingAtoms.forEach(collectPending);\n    pending.forEach(([atom, prevAtomState]) => {\n      const atomState = getAtomState(atom);\n      if (!atomState) {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n        return;\n      }\n      if (atomState !== prevAtomState) {\n        const mounted = mountedMap.get(atom);\n        if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (mounted && !(\n        // TODO This seems pretty hacky. Hope to fix it.\n        // Maybe we could `mountDependencies` in `setAtomState`?\n        !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n          mounted.l.forEach(listener => listener());\n          if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n            flushed.add(atom);\n          }\n        }\n      }\n    });\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = mountAtom(atom);\n    const flushed = flushPending([atom]);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      devListenersRev2.forEach(l => l({\n        type: \"sub\",\n        flushed\n      }));\n    }\n    return () => {\n      listeners.delete(listener);\n      tryUnmountAtom(atom, mounted);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        devListenersRev2.forEach(l => l({\n          type: \"unsub\"\n        }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: l => {\n        devListenersRev2.add(l);\n        return () => {\n          devListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: a => atomStateMap.get(a),\n      dev_get_mounted: a => mountedMap.get(a),\n      dev_restore_atoms: values => {\n        pendingStack.push( /* @__PURE__ */new Set());\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending(pendingStack.pop());\n        devListenersRev2.forEach(l => l({\n          type: \"restore\",\n          flushed\n        }));\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore$1 = () => {\n  if (!defaultStore) {\n    defaultStore = createStore$1();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\");\n      }\n    }\n  }\n  return defaultStore;\n};\nSymbol((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\");\nconst createStore = createStore$1;\nconst getDefaultStore = getDefaultStore$1;\nexport { atom, createStore, getDefaultStore };","map":{"version":3,"names":["keyCount","atom","read","write","key","config","toString","init","defaultRead","defaultWrite","get","set","arg","isSelfAtom","a","unstable_is","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","registerCancelPromise","promise","cancel","catch","finally","delete","cancelPromise","next","resolvePromise","value","status","rejectPromise","e","reason","isPromiseLike","x","then","isEqualAtomValue","b","Object","is","v","isEqualAtomError","hasPromiseAtomValue","Promise","isEqualPromiseAtomValue","orig","returnAtomValue","atomState","createStore$1","atomStateMap","mountedMap","pendingStack","pendingMap","devListenersRev2","mountedAtoms","import","meta","env","MODE","Set","getAtomState","addPendingDependent","d","forEach","_","has","aState","add","setAtomState","_a","freeze","prevAtomState","length","resolve","reject","updateDependencies","nextAtomState","nextDependencies","keepPreviousDependencies","dependencies","Map","changed","console","warn","size","setAtomValue","setAtomValueOrPromise","valueOrPromise","abortPromise","continuePromise","updatePromiseDependencies","mountDependencies","settled","setAtomError","error","readAtomState","force","Array","from","every","s","isSync","getter","aState2","Error","controller","setSelf","options","signal","AbortController","args","writeAtom","abort","readAtom","recomputeDependents","getDependents","_b","dependents","t","dependent","topsortedAtoms","markedAtoms","visit","n","m","push","changedAtoms","isMarked","i","hasChangedDeps","dep","keys","writeAtomState","setter","args2","r","flushed","flushPending","pop","l","type","result","mountAtom","initialDependent","onMountQueue","existingMount","queue","mounted","onMount","onUnmount","u","f","canUnmountAtom","tryUnmountAtom","mountedDep","prevDependencies","depSet","maybeUnmountAtomSet","pendingAtoms","pending","collectPending","pendingAtom","listener","subscribeAtom","listeners","sub","dev_subscribe_store","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","defaultStore","getDefaultStore$1","globalThis","__JOTAI_DEFAULT_STORE__","Symbol","createStore","getDefaultStore"],"sources":["/Users/orcor/react/careplus/node_modules/jotai/esm/vanilla.mjs"],"sourcesContent":["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore$1 = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingStack = [];\n  const pendingMap = /* @__PURE__ */ new WeakMap();\n  let devListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    devListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const addPendingDependent = (atom, atomState) => {\n    atomState.d.forEach((_, a) => {\n      if (!pendingMap.has(a)) {\n        const aState = getAtomState(a);\n        pendingMap.set(a, [aState, /* @__PURE__ */ new Set()]);\n        if (aState) {\n          addPendingDependent(a, aState);\n        }\n      }\n      pendingMap.get(a)[1].add(atom);\n    });\n  };\n  const setAtomState = (atom, atomState) => {\n    var _a;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, [prevAtomState, /* @__PURE__ */ new Set()]);\n      addPendingDependent(atom, atomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\n    const dependencies = new Map(\n      keepPreviousDependencies ? nextAtomState.d : null\n    );\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(\n        atom,\n        nextAtomState,\n        nextDependencies,\n        keepPreviousDependencies\n      );\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!(force == null ? void 0 : force(atom)) && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a, force);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a, force);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const recomputeDependents = (atom) => {\n    const getDependents = (a) => {\n      var _a, _b;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach((dependent) => {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    const topsortedAtoms = new Array();\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    const isMarked = (a) => markedAtoms.has(a);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const prevAtomState = getAtomState(a);\n      if (!prevAtomState) {\n        continue;\n      }\n      let hasChangedDeps = false;\n      for (const dep of prevAtomState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        const nextAtomState = readAtomState(a, isMarked);\n        addPendingDependent(a, nextAtomState);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n      markedAtoms.delete(a);\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      const isSync = pendingStack.length > 0;\n      if (!isSync) {\n        pendingStack.push(/* @__PURE__ */ new Set([a]));\n      }\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending(pendingStack.pop());\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          devListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    pendingStack.push(/* @__PURE__ */ new Set([atom]));\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending(pendingStack.pop());\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      devListenersRev2.forEach((l) => l({ type: \"write\", flushed }));\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const existingMount = mountedMap.get(atom);\n    if (existingMount) {\n      if (initialDependent) {\n        existingMount.t.add(initialDependent);\n      }\n      return existingMount;\n    }\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      if (a !== atom) {\n        mountAtom(a, atom, queue);\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const tryUnmountAtom = (atom, mounted) => {\n    if (!canUnmountAtom(atom, mounted)) {\n      return;\n    }\n    const onUnmount = mounted.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mountedDep = mountedMap.get(a);\n          if (mountedDep) {\n            mountedDep.t.delete(atom);\n            tryUnmountAtom(a, mountedDep);\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach((a) => {\n      mountAtom(a, atom);\n    });\n    maybeUnmountAtomSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        tryUnmountAtom(a, mounted);\n      }\n    });\n  };\n  const flushPending = (pendingAtoms) => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    const pending = [];\n    const collectPending = (pendingAtom) => {\n      var _a;\n      if (!pendingMap.has(pendingAtom)) {\n        return;\n      }\n      const [prevAtomState, dependents] = pendingMap.get(pendingAtom);\n      pendingMap.delete(pendingAtom);\n      pending.push([pendingAtom, prevAtomState]);\n      dependents.forEach(collectPending);\n      (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a) => collectPending(a));\n    };\n    pendingAtoms.forEach(collectPending);\n    pending.forEach(([atom, prevAtomState]) => {\n      const atomState = getAtomState(atom);\n      if (!atomState) {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n        return;\n      }\n      if (atomState !== prevAtomState) {\n        const mounted = mountedMap.get(atom);\n        if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n        // Maybe we could `mountDependencies` in `setAtomState`?\n        (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n          mounted.l.forEach((listener) => listener());\n          if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n            flushed.add(atom);\n          }\n        }\n      }\n    });\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = mountAtom(atom);\n    const flushed = flushPending([atom]);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      devListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      tryUnmountAtom(atom, mounted);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        devListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l) => {\n        devListenersRev2.add(l);\n        return () => {\n          devListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        pendingStack.push(/* @__PURE__ */ new Set());\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending(pendingStack.pop());\n        devListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore$1 = () => {\n  if (!defaultStore) {\n    defaultStore = createStore$1();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\nSymbol(\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\"\n);\n\nconst createStore = createStore$1;\nconst getDefaultStore = getDefaultStore$1;\n\nexport { atom, createStore, getDefaultStore };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}